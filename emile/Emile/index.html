<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Emile (emile.Emile)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0-342-g7e488de"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../index.html">emile</a> &#x00BB; Emile</nav><header><h1>Module <code>Emile</code></h1><p>Emile module, parser of e-mail address.</p></header><nav class="toc"><ul><li><a href="#pretty-printers.">Pretty-printers.</a></li><li><a href="#equal-&amp;-compare.">Equal &amp; Compare.</a></li><li><a href="#parsers">Parsers</a></li></ul></nav><div class="content"><div><div class="spec type" id="type-raw" class="anchored"><a href="#type-raw" class="anchor"></a><code><span class="keyword">type</span> raw = </code><table><tr id="type-raw.Quoted_printable" class="anchored"><td class="def variant constructor"><a href="#type-raw.Quoted_printable" class="anchor"></a><code>| <span class="constructor">Quoted_printable</span> <span class="keyword">of</span> <span><span>(string, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></td></tr><tr id="type-raw.Base64" class="anchored"><td class="def variant constructor"><a href="#type-raw.Base64" class="anchor"></a><code>| <span class="constructor">Base64</span> <span class="keyword">of</span> <span><span>(string, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></td></tr></table></div><div><p>An e-mail address can contain as a part of a <a href="index.html#type-phrase"><code>phrase</code></a> (identifier) an encoded string. Standards describe 2 kinds of encoding:</p><ul><li>Quoted Printable: used to insert hexadecimal value with the <code>=</code> operator.</li><li>Base 64: string encoded in MIME's Base64</li></ul><p>Parser already decodes encoded <a href="index.html#type-raw"><code>raw</code></a>, the client can use it as is.</p></div></div><div><div class="spec type" id="type-word" class="anchored"><a href="#type-word" class="anchor"></a><code><span class="keyword">type</span> word = [ </code><table><tr id="type-word.Atom" class="anchored"><td class="def constructor"><a href="#type-word.Atom" class="anchor"></a><code>| </code><code>`Atom <span class="keyword">of</span> string</code></td></tr><tr id="type-word.String" class="anchored"><td class="def constructor"><a href="#type-word.String" class="anchor"></a><code>| </code><code>`String <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></div><div><p>The local part of an e-mail address is composed by two kinds of <i>word</i>s:</p><ul><li><code>`Atom</code> is string as is.</li><li><code>`String</code> is a string surrounded by double-quote to allow white-space.</li></ul><p>The second kind is sanitized — we deleted double-quote which surround <code>string</code>.</p></div></div><div><div class="spec type" id="type-local" class="anchored"><a href="#type-local" class="anchor"></a><code><span class="keyword">type</span> local = <span><a href="index.html#type-word">word</a> list</span></code></div><div><p>Local part of e-mail address.</p></div></div><div><div class="spec type" id="type-addr" class="anchored"><a href="#type-addr" class="anchor"></a><code><span class="keyword">type</span> addr = </code><table><tr id="type-addr.IPv4" class="anchored"><td class="def variant constructor"><a href="#type-addr.IPv4" class="anchor"></a><code>| <span class="constructor">IPv4</span> <span class="keyword">of</span> <span class="xref-unresolved">Ipaddr</span>.V4.t</code></td></tr><tr id="type-addr.IPv6" class="anchored"><td class="def variant constructor"><a href="#type-addr.IPv6" class="anchor"></a><code>| <span class="constructor">IPv6</span> <span class="keyword">of</span> <span class="xref-unresolved">Ipaddr</span>.V6.t</code></td></tr><tr id="type-addr.Ext" class="anchored"><td class="def variant constructor"><a href="#type-addr.Ext" class="anchor"></a><code>| <span class="constructor">Ext</span> <span class="keyword">of</span> string * string</code></td></tr></table></div><div><p>Subset of domain described by RFC5321 which contains 3 kinds of address:</p><ul><li><code>IPv4</code>: a valid IPv4 address</li><li><code>IPv6</code>: a valid IPv6 address</li><li><code>Ext (ldh, value)</code>: an extended kind of domain recognized by <code>ldh</code> identifier which valus is <code>value</code></li></ul><p>Parser of <code>IPv4</code> and <code>IPv6</code> was done by <code>Ipaddr</code>. An extended kind <code>Ext</code> needs to be resolved by the client.</p></div></div><div><div class="spec type" id="type-domain" class="anchored"><a href="#type-domain" class="anchor"></a><code><span class="keyword">type</span> domain = [ </code><table><tr id="type-domain.Domain" class="anchored"><td class="def constructor"><a href="#type-domain.Domain" class="anchor"></a><code>| </code><code>`Domain <span class="keyword">of</span> <span>string list</span></code></td></tr><tr id="type-domain.Addr" class="anchored"><td class="def constructor"><a href="#type-domain.Addr" class="anchor"></a><code>| </code><code>`Addr <span class="keyword">of</span> <a href="index.html#type-addr">addr</a></code></td></tr><tr id="type-domain.Literal" class="anchored"><td class="def constructor"><a href="#type-domain.Literal" class="anchor"></a><code>| </code><code>`Literal <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></div><div><p>Domain part of e-mail address. A domain integrate kinds from RFC5321 (see <a href="index.html#type-addr"><code>addr</code></a>), a domain described by RFC5322 and a <code>`Literal</code> which is the last <i>best-effort</i> value possible as a domain.</p><p><code>Emile</code> <b>does not</b> resolve domain.</p></div></div><div><div class="spec type" id="type-phrase" class="anchored"><a href="#type-phrase" class="anchor"></a><code><span class="keyword">type</span> phrase = <span><span>[ `Dot <span><span>| `Word</span> of <a href="index.html#type-word">word</a></span> <span><span>| `Encoded</span> of string * <a href="index.html#type-raw">raw</a></span> ]</span> list</span></code></div><div><p>A phrase is a sentence to associate a name with an e-mail address or a group of e-mail addresses. <code>`Encoded</code> value <b>is not</b> normalized on the <i>charset</i> specified. The encoded's string is decoded as is only. For example, <code>`Encoded</code> can inform to use KOI-8 encoding (cyrillic charset). However, <code>Emile</code> does not check if value is a valid KOI-8 string, nor normalizes to unicode. <code>Emile</code> just decodes it as is.</p></div></div><div><div class="spec type" id="type-mailbox" class="anchored"><a href="#type-mailbox" class="anchor"></a><code><span class="keyword">type</span> mailbox = {</code><table><tr id="type-mailbox.name" class="anchored"><td class="def record field"><a href="#type-mailbox.name" class="anchor"></a><code>name : <span><a href="index.html#type-phrase">phrase</a> option</span>;</code></td></tr><tr id="type-mailbox.local" class="anchored"><td class="def record field"><a href="#type-mailbox.local" class="anchor"></a><code>local : <a href="index.html#type-local">local</a>;</code></td></tr><tr id="type-mailbox.domain" class="anchored"><td class="def record field"><a href="#type-mailbox.domain" class="anchor"></a><code>domain : <a href="index.html#type-domain">domain</a> * <span><a href="index.html#type-domain">domain</a> list</span>;</code></td></tr></table><code>}</code></div><div><p>A mailbox is an e-mail address. It contains an optional name (see <a href="index.html#type-phrase"><code>phrase</code></a>), a local-part (see <a href="index.html#type-mailbox.local"><code>local</code></a>) and one or more <a href="index.html#type-mailbox.domain"><code>domain</code></a>(s).</p></div></div><div><div class="spec type" id="type-group" class="anchored"><a href="#type-group" class="anchor"></a><code><span class="keyword">type</span> group = {</code><table><tr id="type-group.group" class="anchored"><td class="def record field"><a href="#type-group.group" class="anchor"></a><code>group : <a href="index.html#type-phrase">phrase</a>;</code></td></tr><tr id="type-group.mailboxes" class="anchored"><td class="def record field"><a href="#type-group.mailboxes" class="anchor"></a><code>mailboxes : <span><a href="index.html#type-mailbox">mailbox</a> list</span>;</code></td></tr></table><code>}</code></div><div><p>A group is a named set of <a href="index.html#type-mailbox"><code>mailbox</code></a>.</p></div></div><div><div class="spec type" id="type-address" class="anchored"><a href="#type-address" class="anchor"></a><code><span class="keyword">type</span> address = <a href="index.html#type-local">local</a> * <span>(<a href="index.html#type-domain">domain</a> * <span><a href="index.html#type-domain">domain</a> list</span>)</span></code></div><div><p>A basic e-mail address.</p></div></div><div><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t = [ </code><table><tr id="type-t.Mailbox" class="anchored"><td class="def constructor"><a href="#type-t.Mailbox" class="anchor"></a><code>| </code><code>`Mailbox <span class="keyword">of</span> <a href="index.html#type-mailbox">mailbox</a></code></td></tr><tr id="type-t.Group" class="anchored"><td class="def constructor"><a href="#type-t.Group" class="anchor"></a><code>| </code><code>`Group <span class="keyword">of</span> <a href="index.html#type-group">group</a></code></td></tr></table><code> ]</code></div><div><p>The <i>Emile</i>'s t type which is a <i>singleton</i> (only one <a href="index.html#type-mailbox"><code>mailbox</code></a>) or a <i>list</i> of e-mail addresses (a <a href="index.html#type-group"><code>group</code></a>).</p></div></div><h3 id="pretty-printers."><a href="#pretty-printers." class="anchor"></a>Pretty-printers.</h3><div class="spec type" id="type-fmt" class="anchored"><a href="#type-fmt" class="anchor"></a><code><span class="keyword">type</span> <span>'a fmt</span> = <span class="xref-unresolved">Stdlib</span>.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></div><div class="spec value" id="val-pp_addr" class="anchored"><a href="#val-pp_addr" class="anchor"></a><code><span class="keyword">val</span> pp_addr : <span><a href="index.html#type-addr">addr</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp_domain" class="anchored"><a href="#val-pp_domain" class="anchor"></a><code><span class="keyword">val</span> pp_domain : <span><a href="index.html#type-domain">domain</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp_word" class="anchored"><a href="#val-pp_word" class="anchor"></a><code><span class="keyword">val</span> pp_word : <span><a href="index.html#type-word">word</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp_local" class="anchored"><a href="#val-pp_local" class="anchor"></a><code><span class="keyword">val</span> pp_local : <span><a href="index.html#type-local">local</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp_raw" class="anchored"><a href="#val-pp_raw" class="anchor"></a><code><span class="keyword">val</span> pp_raw : <span><a href="index.html#type-raw">raw</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp_phrase" class="anchored"><a href="#val-pp_phrase" class="anchor"></a><code><span class="keyword">val</span> pp_phrase : <span><a href="index.html#type-phrase">phrase</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp_mailbox" class="anchored"><a href="#val-pp_mailbox" class="anchor"></a><code><span class="keyword">val</span> pp_mailbox : <span><a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp_group" class="anchored"><a href="#val-pp_group" class="anchor"></a><code><span class="keyword">val</span> pp_group : <span><a href="index.html#type-group">group</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp_address" class="anchored"><a href="#val-pp_address" class="anchor"></a><code><span class="keyword">val</span> pp_address : <span><a href="index.html#type-address">address</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-t">t</a> <a href="index.html#type-fmt">fmt</a></span></code></div><h3 id="equal-&amp;-compare."><a href="#equal-&amp;-compare." class="anchor"></a>Equal &amp; Compare.</h3><div class="spec type" id="type-equal" class="anchored"><a href="#type-equal" class="anchor"></a><code><span class="keyword">type</span> <span>'a equal</span> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></div><div class="spec type" id="type-compare" class="anchored"><a href="#type-compare" class="anchor"></a><code><span class="keyword">type</span> <span>'a compare</span> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></div><div><div class="spec value" id="val-case_sensitive" class="anchored"><a href="#val-case_sensitive" class="anchor"></a><code><span class="keyword">val</span> case_sensitive : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></div><div><p>Alias of <code>String</code>.compare.</p></div></div><div><div class="spec value" id="val-case_insensitive" class="anchored"><a href="#val-case_insensitive" class="anchor"></a><code><span class="keyword">val</span> case_insensitive : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></div><div><p><code>case_insensitive a b</code> maps values with <code>lowercase_ascii</code> and compare them with <code>String</code>.compare. We <b>do not</b> map UTF8 value.</p></div></div><div><div class="spec value" id="val-equal_word" class="anchored"><a href="#val-equal_word" class="anchor"></a><code><span class="keyword">val</span> equal_word : <span>compare:<span>string <a href="index.html#type-compare">compare</a></span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-word">word</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal ~compare a b</code> tests if <a href="index.html#type-word"><code>word</code></a> <code>a</code> and <a href="index.html#type-word"><code>word</code></a> <code>b</code> are semantically equal. <code>compare</code> specifies implementation to compare two <code>string</code> (i.e. to be case-sensitive or not).</p></div></div><div><div class="spec value" id="val-compare_word" class="anchored"><a href="#val-compare_word" class="anchor"></a><code><span class="keyword">val</span> compare_word : <span>?&#8288;case_sensitive:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-word">word</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare_word ?case_sensitive a b</code> compares <a href="index.html#type-word"><code>word</code></a> <code>a</code> and <a href="index.html#type-word"><code>word</code></a> <code>b</code> semantically. From standards, <a href="index.html#type-word"><code>word</code></a> SHOULD be case-sensitive, the client can notice this behaviour by <code>?case_sensitive</code> (default is <code>true</code>).</p></div></div><div><div class="spec value" id="val-equal_raw" class="anchored"><a href="#val-equal_raw" class="anchor"></a><code><span class="keyword">val</span> equal_raw : <span>compare:<span>string <a href="index.html#type-compare">compare</a></span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-raw">raw</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_raw a b</code> tests if <a href="index.html#type-raw"><code>raw</code></a> <code>a</code> and <a href="index.html#type-raw"><code>raw</code></a> <code>b</code> are semantically equal. <i>Semantically equal</i> means we compare raw's content, by this way, a <code>Base64</code> raw could be equal to a <code>Quoted_printable</code> raw if and only if <code>string</code> are equal.</p></div></div><div><div class="spec value" id="val-compare_raw" class="anchored"><a href="#val-compare_raw" class="anchor"></a><code><span class="keyword">val</span> compare_raw : <span>compare:<span>string <a href="index.html#type-compare">compare</a></span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-raw">raw</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare_raw a b</code> compares <a href="index.html#type-raw"><code>raw</code></a> <code>a</code> and <a href="index.html#type-raw"><code>raw</code></a> <code>b</code> semantically.</p></div></div><div><div class="spec value" id="val-equal_phrase" class="anchored"><a href="#val-equal_phrase" class="anchor"></a><code><span class="keyword">val</span> equal_phrase : <span><a href="index.html#type-phrase">phrase</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_phrase a b</code> tests if <a href="index.html#type-phrase"><code>phrase</code></a> <code>a</code> and <a href="index.html#type-phrase"><code>phrase</code></a> <code>b</code> are semantically equal. In this case, the comparison is case-insensitive between elements in <a href="index.html#type-phrase"><code>phrase</code></a>. The order of elements is important.</p></div></div><div><div class="spec value" id="val-compare_phrase" class="anchored"><a href="#val-compare_phrase" class="anchor"></a><code><span class="keyword">val</span> compare_phrase : <span><a href="index.html#type-phrase">phrase</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare_phrase a b</code> compares <a href="index.html#type-phrase"><code>phrase</code></a> <code>a</code> and <a href="index.html#type-phrase"><code>phrase</code></a> <code>b</code> semantically.</p></div></div><div><div class="spec value" id="val-equal_addr" class="anchored"><a href="#val-equal_addr" class="anchor"></a><code><span class="keyword">val</span> equal_addr : <span><a href="index.html#type-addr">addr</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_addr a b</code> tests if <a href="index.html#type-addr"><code>addr</code></a> <code>a</code> and <a href="index.html#type-addr"><code>addr</code></a> <code>b</code> are semantically equal. An <code>IPv4</code> should be equal with an <code>IPv6</code> address. Then, for extended kind, we strictly compare (<code>Pervasives</code>.compare) kind and value.</p></div></div><div><div class="spec value" id="val-compare_addr" class="anchored"><a href="#val-compare_addr" class="anchor"></a><code><span class="keyword">val</span> compare_addr : <span><a href="index.html#type-addr">addr</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare_addr a b</code> compares <a href="index.html#type-addr"><code>addr</code></a> <code>a</code> and <a href="index.html#type-addr"><code>addr</code></a> <code>b</code>, we prioritize <code>IPv6</code>, <code>IPv4</code> and finally <code>Ext</code>.</p></div></div><div><div class="spec value" id="val-equal_domain" class="anchored"><a href="#val-equal_domain" class="anchor"></a><code><span class="keyword">val</span> equal_domain : <span><a href="index.html#type-domain">domain</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_addr a b</code> tests if <a href="index.html#type-mailbox.domain"><code>domain</code></a> <code>a</code> and <a href="index.html#type-mailbox.domain"><code>domain</code></a> <code>b</code> are semantically equal. We <b>do not</b> resolve domain, a <code>`Domain</code> could be semantically equal to another <code>`Domain</code> if they point to the same <code>IPv4</code>/<code>IPv6</code>.</p></div></div><div><div class="spec value" id="val-compare_domain" class="anchored"><a href="#val-compare_domain" class="anchor"></a><code><span class="keyword">val</span> compare_domain : <span><a href="index.html#type-domain">domain</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>comapre_domain a b</code> compares <a href="index.html#type-mailbox.domain"><code>domain</code></a> <code>a</code> and <a href="index.html#type-mailbox.domain"><code>domain</code></a> <code>b</code>, we prioritize <code>`Domain</code>, <code>`Literal</code> and finally <code>`Addr</code>. The comparison between two <code>`Literal</code> and between part of <code>`Domain</code> are case-insensitive.</p></div></div><div><div class="spec value" id="val-equal_domains" class="anchored"><a href="#val-equal_domains" class="anchor"></a><code><span class="keyword">val</span> equal_domains : <span><span>(<a href="index.html#type-domain">domain</a> * <span><a href="index.html#type-domain">domain</a> list</span>)</span> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_domains a b</code> apply <a href="index.html#val-equal_domain"><code>equal_domain</code></a> to ordered domains (see <a href="index.html#val-compare_domain"><code>compare_domain</code></a>) between <code>a</code> and <code>b</code>.</p></div></div><div><div class="spec value" id="val-compare_domains" class="anchored"><a href="#val-compare_domains" class="anchor"></a><code><span class="keyword">val</span> compare_domains : <span><span>(<a href="index.html#type-domain">domain</a> * <span><a href="index.html#type-domain">domain</a> list</span>)</span> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare_domains a b</code> compares ordered list of <a href="index.html#type-mailbox.domain"><code>domain</code></a> <code>a</code> and ordered list of <a href="index.html#type-mailbox.domain"><code>domain</code></a> <code>b</code>.</p></div></div><div><div class="spec value" id="val-equal_local" class="anchored"><a href="#val-equal_local" class="anchor"></a><code><span class="keyword">val</span> equal_local : <span>?&#8288;case_sensitive:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-local">local</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_local ?case_sensitive a b</code> tests if <a href="index.html#type-mailbox.local"><code>local</code></a> <code>a</code> and <a href="index.html#type-mailbox.local"><code>local</code></a> <code>b</code> are semantically equal. Standards notices local-part SHOULD be case-sensitive, the client can choose this behaviour with <code>case_sensitive</code>.</p></div></div><div><div class="spec value" id="val-compare_local" class="anchored"><a href="#val-compare_local" class="anchor"></a><code><span class="keyword">val</span> compare_local : <span>?&#8288;case_sensitive:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-local">local</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare_local ?case_sensitive a b</code> compares <a href="index.html#type-mailbox.local"><code>local</code></a> <code>a</code> and <a href="index.html#type-mailbox.local"><code>local</code></a> <code>b</code> semantically. The user can decide if the comparison is case-sensitive or not (with <code>case_sensitive</code>).</p></div></div><div><div class="spec value" id="val-equal_mailbox" class="anchored"><a href="#val-equal_mailbox" class="anchor"></a><code><span class="keyword">val</span> equal_mailbox : <span>?&#8288;case_sensitive:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_mailbox ?case_sensitive a b</code> tests if <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>a</code> and <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>b</code> are semantically equal. The user can define if the local-part need to be case-sensitive or not (by <code>case_sensitive</code>). If <code>a</code> xor <code>b</code> has a name, we consider <code>a = b</code> if we have the same local-part and same domain(s). Otherwise, we compare identifier/<a href="index.html#type-phrase"><code>phrase</code></a> between them.</p></div></div><div><div class="spec value" id="val-compare_mailbox" class="anchored"><a href="#val-compare_mailbox" class="anchor"></a><code><span class="keyword">val</span> compare_mailbox : <span>?&#8288;case_sensitive:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare ?case_sensitive a b</code> compares <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>a</code> and <code>mailbxo</code> <code>b</code> semantically. We prioritize local-part, domain-part and finally optionnal name.</p></div></div><div><div class="spec value" id="val-compare_group" class="anchored"><a href="#val-compare_group" class="anchor"></a><code><span class="keyword">val</span> compare_group : <span><a href="index.html#type-group">group</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>comapre_group a b</code> compares <a href="index.html#type-group"><code>group</code></a> <code>a</code> and <a href="index.html#type-group"><code>group</code></a> <code>b</code>. We compare the group name first and compare ordered <a href="index.html#type-mailbox"><code>mailbox</code></a>es list then.</p></div></div><div><div class="spec value" id="val-equal_group" class="anchored"><a href="#val-equal_group" class="anchor"></a><code><span class="keyword">val</span> equal_group : <span><a href="index.html#type-group">group</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_group a b</code> tests if <a href="index.html#type-group"><code>group</code></a> <code>a</code> and <a href="index.html#type-group"><code>group</code></a> <code>b</code> are semantically equal. We compare first group name and ordered <a href="index.html#type-mailbox"><code>mailbox</code></a>es list then.</p></div></div><div><div class="spec value" id="val-compare_address" class="anchored"><a href="#val-compare_address" class="anchor"></a><code><span class="keyword">val</span> compare_address : <span><a href="index.html#type-address">address</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare_address a b</code> compares semantically <a href="index.html#type-address"><code>address</code></a> <code>a</code>* and <a href="index.html#type-address"><code>address</code></a> <code>b</code>.</p></div></div><div><div class="spec value" id="val-equal_address" class="anchored"><a href="#val-equal_address" class="anchor"></a><code><span class="keyword">val</span> equal_address : <span><a href="index.html#type-address">address</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal_address a b</code> tests semantically <a href="index.html#type-address"><code>address</code></a> <code>a</code> and <a href="index.html#type-address"><code>address</code></a> <code>b</code>.</p></div></div><div><div class="spec value" id="val-equal_set" class="anchored"><a href="#val-equal_set" class="anchor"></a><code><span class="keyword">val</span> equal_set : <span><a href="index.html#type-t">t</a> <a href="index.html#type-equal">equal</a></span></code></div><div><p><code>equal a b</code> tests semantically <code>set</code> <code>a</code> and <code>set</code> <code>b</code>.</p></div></div><div><div class="spec value" id="val-compare_set" class="anchored"><a href="#val-compare_set" class="anchor"></a><code><span class="keyword">val</span> compare_set : <span><a href="index.html#type-t">t</a> <a href="index.html#type-compare">compare</a></span></code></div><div><p><code>compare a b</code> compares <code>set</code> <code>a</code> and <code>set</code> <code>b</code>.</p></div></div><h3 id="parsers"><a href="#parsers" class="anchor"></a>Parsers</h3><aside><p>If you don't want a headache, you should move on.</p></aside><div class="spec module" id="module-Parser" class="anchored"><a href="#module-Parser" class="anchor"></a><code><span class="keyword">module</span> <a href="Parser/index.html">Parser</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error = [ </code><table><tr id="type-error.Invalid" class="anchored"><td class="def constructor"><a href="#type-error.Invalid" class="anchor"></a><code>| </code><code>`Invalid <span class="keyword">of</span> string * string</code></td></tr></table><code> ]</code></div><div><p>The error type.</p></div></div><div><div class="spec value" id="val-pp_error" class="anchored"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <span><a href="index.html#type-error">error</a> <a href="index.html#type-fmt">fmt</a></span></code></div><div><p><code>pp_error ppf err</code> is pretty-printer of <a href="index.html#type-error"><code>error</code></a>.</p></div></div><div class="spec module" id="module-List" class="anchored"><a href="#module-List" class="anchor"></a><code><span class="keyword">module</span> <a href="List/index.html">List</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-address_of_string_with_crlf" class="anchored"><a href="#val-address_of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> address_of_string_with_crlf : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-address">address</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div><p><code>address_of_string_with_crlf s</code> parses <code>s</code> which have the form: <code>local@domain</code>. Named email or multiple-domain email are not handle by this parser. <code>s</code> must terminate with <code>CRLF</code> as the delimiter. If the parser fails, it return an error <a href="index.html#type-error"><code>error</code></a>.</p></div></div><div><div class="spec value" id="val-address_of_string" class="anchored"><a href="#val-address_of_string" class="anchor"></a><code><span class="keyword">val</span> address_of_string : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-address">address</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div><p><code>address_of_string s</code> parses <code>s</code> which have the form: <code>local@domain</code>. Named email or multiple-domain email are not handle by this function. If the parser fails, it return an error <a href="index.html#type-error"><code>error</code></a>. It's possible that <code>address_of_string</code> did not consume all <code>s</code>.</p></div></div><div><div class="spec value" id="val-address_of_string_raw" class="anchored"><a href="#val-address_of_string_raw" class="anchor"></a><code><span class="keyword">val</span> address_of_string_raw : <span>off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <span>?&#8288;tmp:<span class="xref-unresolved">Bigstringaf</span>.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(int * <a href="index.html#type-address">address</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div><p><code>address_of_string_raw s off len</code> parses a sub-part of <code>s</code> starting at <code>off</code> and it computes at most <code>len</code> bytes. It returns the email and how many bytes it consumes. Named email or multiple-domain are not handle by this parser. If the parser fails, it return an error <a href="index.html#type-error"><code>error</code></a>.</p><p>If the user has an already allocated <code>Bigstringaf</code>.t, it can use it as an internal buffer to parse given input <code>s</code>.</p></div></div><div class="spec value" id="val-set_of_string_with_crlf" class="anchored"><a href="#val-set_of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> set_of_string_with_crlf : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div class="spec value" id="val-set_of_string" class="anchored"><a href="#val-set_of_string" class="anchor"></a><code><span class="keyword">val</span> set_of_string : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div class="spec value" id="val-set_of_string_raw" class="anchored"><a href="#val-set_of_string_raw" class="anchor"></a><code><span class="keyword">val</span> set_of_string_raw : <span>off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <span>?&#8288;tmp:<span class="xref-unresolved">Bigstringaf</span>.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(int * <a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div><div class="spec value" id="val-of_string_with_crlf" class="anchored"><a href="#val-of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> of_string_with_crlf : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-mailbox">mailbox</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div><p><code>of_string_with_crlf s</code> parses <code>s</code> which can have multiple form:</p><ul><li>Named email <code>Bobby &lt;bobby@mail.net&gt;</code></li><li>Multiple-domain email <code>&lt;@laposte.net:bobby@mail.net</code></li><li>Usual form <code>bobby@mail.net</code></li><li>Surrounded form <code>&lt;bobby@mail.net&gt;</code></li></ul><p>About named email, the parser handles <i>encoded-word</i> (according RFC 2047) to be able to use a special <i>charset</i> (like UTF-8) to show the name. Parser decodes <i>encoded-word</i> as is and do not do any translation from <i>charset</i> specified to any encoding (eg. translation from <i>latin1</i> to <i>UTF-8</i>).</p><p><code>s</code> must terminates with <code>CRLF</code> as the delimiter. If the parser fails, it return an error <a href="index.html#type-error"><code>error</code></a>.</p></div></div><div><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-mailbox">mailbox</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div><p><code>of_string s</code> is <a href="index.html#val-of_string_with_crlf"><code>of_string_with_crlf</code></a> but did not need <code>CRLF</code> at the end. It's possible that <code>of_string</code> did not consume all <code>s</code>.</p></div></div><div><div class="spec value" id="val-of_string_raw" class="anchored"><a href="#val-of_string_raw" class="anchor"></a><code><span class="keyword">val</span> of_string_raw : <span>off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <span>?&#8288;tmp:<span class="xref-unresolved">Bigstringaf</span>.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(int * <a href="index.html#type-mailbox">mailbox</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></code></div><div><p><code>of_string_raw s off len</code> is <a href="index.html#val-of_string_with_crlf"><code>of_string_with_crlf</code></a> but did not need <code>CRLF</code> at the end. It parses only a sub-part of <code>s</code> starting at <code>off</code> and computes at most <code>len</code> bytes. It returns how many bytes it consumed.</p><p>If the user has an already allocated <code>Bigstringaf</code>.t, it can use it as an internal buffer to parse given input <code>s</code>.</p></div></div><div><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-mailbox">mailbox</a> <span>&#45;&gt;</span> string</code></div><div><p><code>to_string mailbox</code> returns a well-formed string which represents the given <a href="index.html#type-mailbox"><code>mailbox</code></a> value.</p></div></div><div><div class="spec value" id="val-set_to_string" class="anchored"><a href="#val-set_to_string" class="anchor"></a><code><span class="keyword">val</span> set_to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></div><div><p><code>set_to_string t</code> returns a well-formed string which represents the given <a href="index.html#type-t"><code>t</code></a> value.</p></div></div><div><div class="spec value" id="val-address_to_string" class="anchored"><a href="#val-address_to_string" class="anchor"></a><code><span class="keyword">val</span> address_to_string : <a href="index.html#type-address">address</a> <span>&#45;&gt;</span> string</code></div><div><p><code>address_to_string address</code> returns a well-formed string which represents the given <a href="index.html#type-address"><code>address</code></a> value.</p></div></div></div></body></html>