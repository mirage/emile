<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Emile (emile.Emile)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">emile</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Emile</span></h1></header><p>Emile module, parser of e-mail address.</p><div class="spec type" id="type-raw"><a href="#type-raw" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>raw</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-raw.Quoted_printable" class="anchored"><td class="def constructor"><a href="#type-raw.Quoted_printable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Quoted_printable</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-raw.Base64" class="anchored"><td class="def constructor"><a href="#type-raw.Base64" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Base64</span><span class="keyword"> of </span>[ `Dirty of string | `Clean of string | `Wrong_padding ]</code></td></tr></table><code></code></div><div class="doc"><p>An e-mail address can contain as a part of a <a href="index.html#type-phrase">phrase</a> (identifier) an
encoded string. Standards describe 2 kinds of encoding:</p><ul><li>Quoted Printable: used to insert hexadecimal value with the <code class="code">=</code> operator.</li><li>Base 64: string encoded in MIME's Base64</li></ul><p>Parser already decodes encoded <a href="index.html#type-raw">raw</a>, the client can use it as is.</p></div></div><div class="spec type" id="type-word"><a href="#type-word" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>word</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-word.Atom" class="anchored"><td class="def constructor"><a href="#type-word.Atom" class="anchor"></a><code><span class="keyword">| </span></code><code>`Atom<span class="keyword"> of </span>string</code></td></tr><tr id="type-word.String" class="anchored"><td class="def constructor"><a href="#type-word.String" class="anchor"></a><code><span class="keyword">| </span></code><code>`String<span class="keyword"> of </span>string</code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>The local part of an e-mail address is composed by two kinds of <i>word</i>s:</p><ul><li><code class="code">`Atom</code> is string as is.</li><li><code class="code">`String</code> is a string surrounded by double-quote to allow white-space.</li></ul><p>The second kind is sanitized — we deleted double-quote which surround
<code class="code">string</code>.</p></div></div><div class="spec type" id="type-local"><a href="#type-local" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>local</code><code><span class="keyword"> = </span><a href="index.html#type-word">word</a> list</code><code></code></div><div class="doc"><p>Local part of e-mail address.</p></div></div><div class="spec type" id="type-addr"><a href="#type-addr" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>addr</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-addr.IPv4" class="anchored"><td class="def constructor"><a href="#type-addr.IPv4" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">IPv4</span><span class="keyword"> of </span>Ipaddr.V4.t</code></td></tr><tr id="type-addr.IPv6" class="anchored"><td class="def constructor"><a href="#type-addr.IPv6" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">IPv6</span><span class="keyword"> of </span>Ipaddr.V6.t</code></td></tr><tr id="type-addr.Ext" class="anchored"><td class="def constructor"><a href="#type-addr.Ext" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Ext</span><span class="keyword"> of </span>string<span class="keyword"> * </span>string</code></td></tr></table><code></code></div><div class="doc"><p>Subset of domain described by RFC5321 which contains 3 kinds of address:</p><ul><li><code class="code">IPv4</code>: a valid IPv4 address</li><li><code class="code">IPv6</code>: a valid IPv6 address</li><li><code class="code">Ext (ldh, value)</code>: an extended kind of domain recognized by <code class="code">ldh</code>
identifier which valus is <code class="code">value</code></li></ul><p>Parser of <code class="code">IPv4</code> and <code class="code">IPv6</code> was done by <code class="code">Ipaddr</code>. An extended kind <code class="code">Ext</code>
needs to be resolved by the client.</p></div></div><div class="spec type" id="type-domain"><a href="#type-domain" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>domain</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-domain.Domain" class="anchored"><td class="def constructor"><a href="#type-domain.Domain" class="anchor"></a><code><span class="keyword">| </span></code><code>`Domain<span class="keyword"> of </span>string list</code></td></tr><tr id="type-domain.Addr" class="anchored"><td class="def constructor"><a href="#type-domain.Addr" class="anchor"></a><code><span class="keyword">| </span></code><code>`Addr<span class="keyword"> of </span><a href="index.html#type-addr">addr</a></code></td></tr><tr id="type-domain.Literal" class="anchored"><td class="def constructor"><a href="#type-domain.Literal" class="anchor"></a><code><span class="keyword">| </span></code><code>`Literal<span class="keyword"> of </span>string</code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>Domain part of e-mail address. A domain integrate kinds from RFC5321 (see
<a href="index.html#type-addr">addr</a>), a domain described by RFC5322 and a <code class="code">`Literal</code> which is the last <i>best-effort</i> value possible as a domain.</p><p><code class="code">Emile</code><b>does not</b> resolve domain.</p></div></div><div class="spec type" id="type-phrase"><a href="#type-phrase" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>phrase</code><code><span class="keyword"> = </span>[ `Dot | `Word of <a href="index.html#type-word">word</a> | `Encoded of string<span class="keyword"> * </span><a href="index.html#type-raw">raw</a> ] list</code><code></code></div><div class="doc"><p>A phrase is a sentence to associate a name with an e-mail address or a group
of e-mail addresses. <code class="code">`Encoded</code> value <b>is not</b> normalized on the <i>charset</i> specified. The encoded's string is decoded as is only. For example,
<code class="code">`Encoded</code> can inform to use KOI-8 encoding (cyrillic charset). However,
<code class="code">Emile</code> does not check if value is a valid KOI-8 string, nor normalizes to
unicode. <code class="code">Emile</code> just decodes it as is.</p></div></div><div class="spec type" id="type-mailbox"><a href="#type-mailbox" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>mailbox</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-mailbox.name" class="anchored"><td class="def field"><a href="#type-mailbox.name" class="anchor"></a><code>name : <a href="index.html#type-phrase">phrase</a> option;</code></td></tr><tr id="type-mailbox.local" class="anchored"><td class="def field"><a href="#type-mailbox.local" class="anchor"></a><code>local : <a href="index.html#type-local">local</a>;</code></td></tr><tr id="type-mailbox.domain" class="anchored"><td class="def field"><a href="#type-mailbox.domain" class="anchor"></a><code>domain : <a href="index.html#type-domain">domain</a><span class="keyword"> * </span><a href="index.html#type-domain">domain</a> list;</code></td></tr></table><code>}</code><code></code></div><div class="doc"><p>A mailbox is an e-mail address. It contains an optional name (see
<a href="index.html#type-phrase">phrase</a>), a local-part <span class="see"><a href="index.html#type-local">local</a></span> and one or more <a href="index.html#type-domain">domain</a>(s).</p></div></div><div class="spec type" id="type-group"><a href="#type-group" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>group</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-group.group" class="anchored"><td class="def field"><a href="#type-group.group" class="anchor"></a><code>group : <a href="index.html#type-phrase">phrase</a>;</code></td></tr><tr id="type-group.mailboxes" class="anchored"><td class="def field"><a href="#type-group.mailboxes" class="anchor"></a><code>mailboxes : <a href="index.html#type-mailbox">mailbox</a> list;</code></td></tr></table><code>}</code><code></code></div><div class="doc"><p>A group is a named set of <a href="index.html#type-mailbox">mailbox</a>.</p></div></div><div class="spec type" id="type-address"><a href="#type-address" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>address</code><code><span class="keyword"> = </span><a href="index.html#type-local">local</a><span class="keyword"> * </span>(<a href="index.html#type-domain">domain</a><span class="keyword"> * </span><a href="index.html#type-domain">domain</a> list)</code><code></code></div><div class="doc"><p>A basic e-mail address.</p></div></div><div class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>set</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-set.Mailbox" class="anchored"><td class="def constructor"><a href="#type-set.Mailbox" class="anchor"></a><code><span class="keyword">| </span></code><code>`Mailbox<span class="keyword"> of </span><a href="index.html#type-mailbox">mailbox</a></code></td></tr><tr id="type-set.Group" class="anchored"><td class="def constructor"><a href="#type-set.Group" class="anchor"></a><code><span class="keyword">| </span></code><code>`Group<span class="keyword"> of </span><a href="index.html#type-group">group</a></code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>The <i>Emile</i>'s set type which is a <i>singleton</i> (only one <a href="index.html#type-mailbox">mailbox</a>) or a
<i>set</i> of e-mail addresses (a <a href="index.html#type-group">group</a>).</p></div></div><h3>Pretty-printer</h3><div class="spec val" id="val-pp_addr"><a href="#val-pp_addr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_addr : <a href="index.html#type-addr">addr</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_domain"><a href="#val-pp_domain" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_domain : <a href="index.html#type-domain">domain</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_word"><a href="#val-pp_word" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_word : <a href="index.html#type-word">word</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_local"><a href="#val-pp_local" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_local : <a href="index.html#type-local">local</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_raw"><a href="#val-pp_raw" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_raw : <a href="index.html#type-raw">raw</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_phrase"><a href="#val-pp_phrase" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_phrase : <a href="index.html#type-phrase">phrase</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_mailbox"><a href="#val-pp_mailbox" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_mailbox : <a href="index.html#type-mailbox">mailbox</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_group"><a href="#val-pp_group" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_group : <a href="index.html#type-group">group</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_address"><a href="#val-pp_address" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_address : <a href="index.html#type-address">address</a> Fmt.t</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_set"><a href="#val-pp_set" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_set : <a href="index.html#type-set">set</a> Fmt.t</code></div><div class="doc"></div></div><h3>Equal &amp; Compare</h3><div class="spec type" id="type-equal"><a href="#type-equal" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a equal</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> bool</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-compare"><a href="#type-compare" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a compare</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> int</code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-case_sensitive"><a href="#val-case_sensitive" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>case_sensitive : string <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p>Alias of <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;">String.compare</span>.</p></div></div><div class="spec val" id="val-case_insensitive"><a href="#val-case_insensitive" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>case_insensitive : string <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">case_insensitive a b</code> maps values with lowercase_ascii and compare them
with <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;">String.compare</span>. We <b>do not</b> map UTF8 value.</p></div></div><div class="spec val" id="val-equal_word"><a href="#val-equal_word" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_word : compare:string <a href="index.html#type-compare">compare</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-word">word</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal ~compare a b</code> tests if <a href="index.html#type-word">word</a><code class="code">a</code> and <a href="index.html#type-word">word</a><code class="code">b</code> are semantically
equal. <code class="code">compare</code> specifies implementation to compare two <code class="code">string</code> (i.e. to be
case-sensitive or not).</p></div></div><div class="spec val" id="val-compare_word"><a href="#val-compare_word" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_word : ?&#8288;case_sensitive:bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-word">word</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare_word ?case_sensitive a b</code> compares <a href="index.html#type-word">word</a><code class="code">a</code> and <a href="index.html#type-word">word</a><code class="code">b</code>
semantically. From standards, <a href="index.html#type-word">word</a> SHOULD be case-sensitive, the client
can notice this behaviour by <code class="code">?case_sensitive</code> (default is <code class="code">true</code>).</p></div></div><div class="spec val" id="val-equal_raw"><a href="#val-equal_raw" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_raw : compare:string <a href="index.html#type-compare">compare</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-raw">raw</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_raw a b</code> tests if <a href="index.html#type-raw">raw</a><code class="code">a</code> and <a href="index.html#type-raw">raw</a><code class="code">b</code> are semantically equal.
<i>Semantically equal</i> means we compare raw's content, by this way, a
<code class="code">Base64</code> raw could be equal to a <code class="code">Quoted_printable</code> raw if and only if
<code class="code">string</code> are equal.</p></div></div><div class="spec val" id="val-compare_raw"><a href="#val-compare_raw" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_raw : compare:string <a href="index.html#type-compare">compare</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-raw">raw</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare_raw a b</code> compares <a href="index.html#type-raw">raw</a><code class="code">a</code> and <a href="index.html#type-raw">raw</a><code class="code">b</code> semantically.</p></div></div><div class="spec val" id="val-equal_phrase"><a href="#val-equal_phrase" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_phrase : <a href="index.html#type-phrase">phrase</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_phrase a b</code> tests if <a href="index.html#type-phrase">phrase</a><code class="code">a</code> and <a href="index.html#type-phrase">phrase</a><code class="code">b</code> are semantically
equal. In this case, the comparison is case-insensitive between elements in
<a href="index.html#type-phrase">phrase</a>. The order of elements is important.</p></div></div><div class="spec val" id="val-compare_phrase"><a href="#val-compare_phrase" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_phrase : <a href="index.html#type-phrase">phrase</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare_phrase a b</code> compares <a href="index.html#type-phrase">phrase</a><code class="code">a</code> and <a href="index.html#type-phrase">phrase</a><code class="code">b</code> semantically.</p></div></div><div class="spec val" id="val-equal_addr"><a href="#val-equal_addr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_addr : <a href="index.html#type-addr">addr</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_addr a b</code> tests if <a href="index.html#type-addr">addr</a><code class="code">a</code> and <a href="index.html#type-addr">addr</a><code class="code">b</code> are semantically
equal. An <code class="code">IPv4</code> should be equal with an <code class="code">IPv6</code> address. Then, for extended
kind, we strictly compare (<span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.compare&quot;">Pervasives.compare</span>) kind and value.</p></div></div><div class="spec val" id="val-compare_addr"><a href="#val-compare_addr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_addr : <a href="index.html#type-addr">addr</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare_addr a b</code> compares <a href="index.html#type-addr">addr</a><code class="code">a</code> and <a href="index.html#type-addr">addr</a><code class="code">b</code>, we prioritize
<code class="code">IPv6</code>, <code class="code">IPv4</code> and finally <code class="code">Ext</code>.</p></div></div><div class="spec val" id="val-equal_domain"><a href="#val-equal_domain" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_domain : <a href="index.html#type-domain">domain</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_addr a b</code> tests if <a href="index.html#type-domain">domain</a><code class="code">a</code> and <a href="index.html#type-domain">domain</a><code class="code">b</code> are semantically
equal. We <b>do not</b> resolve domain, a <code class="code">`Domain</code> could be semantically equal
to another <code class="code">`Domain</code> if they point to the same <code class="code">IPv4</code>/<code class="code">IPv6</code>.</p></div></div><div class="spec val" id="val-compare_domain"><a href="#val-compare_domain" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_domain : <a href="index.html#type-domain">domain</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">comapre_domain a b</code> compares <a href="index.html#type-domain">domain</a><code class="code">a</code> and <a href="index.html#type-domain">domain</a><code class="code">b</code>, we prioritize
<code class="code">`Domain</code>, <code class="code">`Literal</code> and finally <code class="code">`Addr</code>. The comparison between two
<code class="code">`Literal</code> and between part of <code class="code">`Domain</code> are case-insensitive.</p></div></div><div class="spec val" id="val-equal_domains"><a href="#val-equal_domains" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_domains : (<a href="index.html#type-domain">domain</a><span class="keyword"> * </span><a href="index.html#type-domain">domain</a> list) <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_domains a b</code> apply <a href="index.html#val-equal_domain">equal_domain</a> to ordered domains (see
<a href="index.html#val-compare_domain">compare_domain</a>) between <code class="code">a</code> and <code class="code">b</code>.</p></div></div><div class="spec val" id="val-compare_domains"><a href="#val-compare_domains" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_domains : (<a href="index.html#type-domain">domain</a><span class="keyword"> * </span><a href="index.html#type-domain">domain</a> list) <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare_domains a b</code> compares ordered list of <a href="index.html#type-domain">domain</a><code class="code">a</code> and ordered
list of <a href="index.html#type-domain">domain</a><code class="code">b</code>.</p></div></div><div class="spec val" id="val-equal_local"><a href="#val-equal_local" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_local : ?&#8288;case_sensitive:bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-local">local</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_local ?case_sensitive a b</code> tests if <a href="index.html#type-local">local</a><code class="code">a</code> and <a href="index.html#type-local">local</a><code class="code">b</code> are
semantically equal. Standards notices local-part SHOULD be case-sensitive,
the client can choose this behaviour with <code class="code">case_sensitive</code>.</p></div></div><div class="spec val" id="val-compare_local"><a href="#val-compare_local" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_local : ?&#8288;case_sensitive:bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-local">local</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare_local ?case_sensitive a b</code> compares <a href="index.html#type-local">local</a><code class="code">a</code> and <a href="index.html#type-local">local</a><code class="code">b</code>
semantically. The user can decide if the comparison is case-sensitive or not
(with <code class="code">case_sensitive</code>).</p></div></div><div class="spec val" id="val-equal_mailbox"><a href="#val-equal_mailbox" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_mailbox : ?&#8288;case_sensitive:bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_mailbox ?case_sensitive a b</code> tests if <a href="index.html#type-mailbox">mailbox</a><code class="code">a</code> and <a href="index.html#type-mailbox">mailbox</a><code class="code">b</code> are semantically equal. The user can define if the local-part need to be
case-sensitive or not (by <code class="code">case_sensitive</code>). If <code class="code">a</code> xor <code class="code">b</code> has a name, we
consider <code class="code">a = b</code> if we have the same local-part and same domain(s).
Otherwise, we compare identifier/<a href="index.html#type-phrase">phrase</a> between them.</p></div></div><div class="spec val" id="val-compare_mailbox"><a href="#val-compare_mailbox" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_mailbox : ?&#8288;case_sensitive:bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare ?case_sensitive a b</code> compares <a href="index.html#type-mailbox">mailbox</a><code class="code">a</code> and mailbxo<code class="code">b</code>
semantically. We prioritize local-part, domain-part and finally optionnal
name.</p></div></div><div class="spec val" id="val-compare_group"><a href="#val-compare_group" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_group : <a href="index.html#type-group">group</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">comapre_group a b</code> compares <a href="index.html#type-group">group</a><code class="code">a</code> and <a href="index.html#type-group">group</a><code class="code">b</code>. We compare the
group name first and compare ordered <a href="index.html#type-mailbox">mailbox</a>es list then.</p></div></div><div class="spec val" id="val-equal_group"><a href="#val-equal_group" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_group : <a href="index.html#type-group">group</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_group a b</code> tests if <a href="index.html#type-group">group</a><code class="code">a</code> and <a href="index.html#type-group">group</a><code class="code">b</code> are semantically
equal. We compare first group name and ordered <a href="index.html#type-mailbox">mailbox</a>es list then.</p></div></div><div class="spec val" id="val-compare_address"><a href="#val-compare_address" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_address : <a href="index.html#type-address">address</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare_address a b</code> compares semantically <a href="index.html#type-address">address</a><code class="code">a</code>* and <a href="index.html#type-address">address</a><code class="code">b</code>.</p></div></div><div class="spec val" id="val-equal_address"><a href="#val-equal_address" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_address : <a href="index.html#type-address">address</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal_address a b</code> tests semantically <a href="index.html#type-address">address</a><code class="code">a</code> and <a href="index.html#type-address">address</a><code class="code">b</code>.</p></div></div><div class="spec val" id="val-equal_set"><a href="#val-equal_set" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal_set : <a href="index.html#type-set">set</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p><code class="code">equal a b</code> tests semantically <a href="index.html#type-set">set</a><code class="code">a</code> and <a href="index.html#type-set">set</a><code class="code">b</code>.</p></div></div><div class="spec val" id="val-compare_set"><a href="#val-compare_set" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_set : <a href="index.html#type-set">set</a> <a href="index.html#type-compare">compare</a></code></div><div class="doc"><p><code class="code">compare a b</code> compares <a href="index.html#type-set">set</a><code class="code">a</code> and <a href="index.html#type-set">set</a><code class="code">b</code>.</p></div></div><div class="spec val" id="val-strictly_equal_set"><a href="#val-strictly_equal_set" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>strictly_equal_set : <a href="index.html#type-set">set</a> <a href="index.html#type-equal">equal</a></code></div><div class="doc"><p>A structurally equal function on <a href="index.html#type-set">set</a>.</p></div></div><h3>Parsers</h3><p>If you don't want a headache, you should move on.</p><div class="spec module" id="module-Parser"><a href="#module-Parser" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Parser/index.html">Parser</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><h3>Decoders</h3><p>We have 4 kinds of parsers for e-mail address:</p><ul><li><p><code class="code">List.of_string*</code> is the most general parser which used as the parser of
<code class="code">To:</code> field into an e-mail. Indeed, this value is a list of <a href="index.html#type-set">set</a> which can
contain only one e-mail address or a named group of e-mail addresses.</p><p>This parser is used into tests of <code class="code">Emile</code>.</p></li><li><code class="code">address_of_string*</code> is the parser of e-mail address like
<code class="code">local-part@domain</code>. This is the most common (in your mind) case for the
client to parse an e-mail address. This parser does not handle a named e-mail
address or a multiple domains e-mail address however.</li><li><code class="code">set_of_string*</code> is the parser which performs a named group of e-mail
addresses (<a href="index.html#type-group">group</a>) or an optionaly named e-mail address (<a href="index.html#type-mailbox">mailbox</a>). In
constrast to <a href="index.html#val-address_of_string">address_of_string</a>, this parser handles multiple domains
e-mail address.</li><li><code class="code">of_string*</code> is the most general unit parser of e-mail address. That
means, this parser is like <a href="index.html#val-set_of_string">set_of_string</a><b>without</b> a named group of
e-mail addresses. It handles named e-mail address and multiple domains e-mail
address. The client should use this function if he does not know exactly the
format of input.</li></ul><p>For each parser, you have the common <code class="code">of_string</code> function, the
<code class="code">of_string_with_crlf</code> function and finally the <code class="code">of_string_raw</code> function. The
first one is the most easy to understand, it takes your string and try to
extract an e-mail address (or a set or a list of set).</p><p>Then, the second is a more general parser. The delimiter of an e-mail
address into an e-mail context is a double CRLF code (to stop the <i>folding
whitespace</i> rule). Indeed, an e-mail can be encoded on multiple lines... So,
<code class="code">of_string</code> function is a special case of <code class="code">of_string_with_crlf</code> where we put
a double CRLF code at the end of your string to ensure to stop parser
somewhere.</p><p>The final function, <code class="code">of_string_raw</code> could be interesting client who wants to
integrate <code class="code">Emile</code> inside a parser. This function compute only a slice of your
string and returns how many bytes it consumed to extract e-mail address.
Internal stuff put CRLF code too to stop parser and uncount CRLF code when it
returns how many byte(s) it consumed.</p><p>For client who wants to use <code class="code">Emile</code> into an existing parser, your e-mail
address should be delimited or surrounded by characters. For example, you can
have an e-mail in this form: <code class="code">&lt;local@domain&gt;</code>. In this example, e-mail
address is surrounded by <code class="code">&lt;</code> and <code class="code">&gt;</code>. Your goal is to extract string inside
them and use <a href="index.html#val-address_of_string">address_of_string</a> which does not allow <code class="code">&lt;</code> and <code class="code">&gt;</code> into
e-mail address.</p><p>In other case, your e-mail address can have this form: <code class="code">John
   &lt;local@domain&gt;\n</code>. In this case, your e-mail address is delimited by <code class="code">\n</code> and
you should use <a href="index.html#val-of_string">of_string</a> which will compute name (<code class="code">John</code>) and associated
e-mail address.</p><p>By these examples, extract an e-mail address is clearly not easy because it
can take different forms and client needs to figure out what he clearly
needs. Then, these parsers can fail for different non-obvious reasons - and,
in this case, client needs to understand standards sadly to understand where
is specially the problem.</p><p>In other way, if client is comfortable with Angstrom, <code class="code">Emile</code> provides
indigestible parsers (see <a href="Parser/index.html">Parser</a>).</p><div class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>error</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-error.Invalid" class="anchored"><td class="def constructor"><a href="#type-error.Invalid" class="anchor"></a><code><span class="keyword">| </span></code><code>`Invalid<span class="keyword"> of </span>string<span class="keyword"> * </span>string list</code></td></tr><tr id="type-error.Incomplete" class="anchored"><td class="def constructor"><a href="#type-error.Incomplete" class="anchor"></a><code><span class="keyword">| </span></code><code>`Incomplete</code></td></tr></table><code> ]</code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_error : <a href="index.html#type-error">error</a> Fmt.t</code></div><div class="doc"><p><code class="code">pp_error ppf err</code> prints an <a href="index.html#type-error">error</a>.</p></div></div><div class="spec module" id="module-List"><a href="#module-List" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="List/index.html">List</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec val" id="val-address_of_string_with_crlf"><a href="#val-address_of_string_with_crlf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>address_of_string_with_crlf : string <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-address">address</a>, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div><div class="spec val" id="val-address_of_string"><a href="#val-address_of_string" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>address_of_string : string <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-address">address</a>, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div><div class="spec val" id="val-address_of_string_raw"><a href="#val-address_of_string_raw" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>address_of_string_raw : string <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-address">address</a><span class="keyword"> * </span>int, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div><div class="spec val" id="val-set_of_string_with_crlf"><a href="#val-set_of_string_with_crlf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>set_of_string_with_crlf : string <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-set">set</a>, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div><div class="spec val" id="val-set_of_string"><a href="#val-set_of_string" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>set_of_string : string <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-set">set</a>, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div><div class="spec val" id="val-set_of_string_raw"><a href="#val-set_of_string_raw" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>set_of_string_raw : string <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-set">set</a><span class="keyword"> * </span>int, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div><div class="spec val" id="val-of_string_with_crlf"><a href="#val-of_string_with_crlf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_string_with_crlf : string <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a>, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div><div class="spec val" id="val-of_string"><a href="#val-of_string" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_string : string <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a>, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div><div class="spec val" id="val-of_string_raw"><a href="#val-of_string_raw" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_string_raw : string <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a><span class="keyword"> * </span>int, <a href="index.html#type-error">error</a>) Pervasives.result</code></div><div class="doc"></div></div></body></html>